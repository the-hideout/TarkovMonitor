@using System.ComponentModel
@using Humanizer
@inject MessageLog messageLog
@inject LocalizationService LocalizationService

<MudDialog>
    <DialogContent>
        <MudText>
            @LocalizationService.GetString("CurrentProfile"): @GameWatcher.CurrentProfile.Id (@GameWatcher.CurrentProfile.Type)
        </MudText>
        <MudText>
            @LocalizationService.GetString("IfYouWantToUpdateProgressForDifferentProfile")
        </MudText>
        @if (customWatcher.LogsPath != "")
        {
            if (breakpoints != null)
            {
                <MudSelect @bind-Value="selectedBreakpoint" Label="@LocalizationService.GetString("ReadPreviousLogsLabel")" HelperText="@LocalizationService.GetString("ChooseStartingPointHelperText")" OpenIcon="@Icons.Material.Filled.TextSnippet" AdornmentColor="Color.Secondary">
                    @foreach (LogDetails breakpoint in breakpoints)
                    {
                        <MudSelectItem Value="@breakpoint">@breakpoint.Version | @breakpoint.Date.ToLongDateString() - @breakpoint.Date.Humanize()</MudSelectItem>
                    }
                </MudSelect>
                <p>@LocalizationService.GetString("SelectStartingPointDescription")</p>
                <p><strong>@LocalizationService.GetString("WarningMessage")</strong></p>
            }
            else
            {
                <MudProgressCircular Color="Color.Info" Indeterminate="true" />
            }
            
        }
        else
        {
            <span>@LocalizationService.GetString("CouldNotFindEFTInstallation")</span>
        }
    </DialogContent>
    <DialogActions>
        <MudButton OnClick="Cancel">@LocalizationService.GetString("Cancel")</MudButton>
        <MudButton Color="Color.Primary" OnClick="Submit" Disabled="@SubmitDisabled">@LocalizationService.GetString("Ok")</MudButton>
    </DialogActions>
</MudDialog>
@code {
    [CascadingParameter] MudDialogInstance MudDialog { get; set; }

    internal GameWatcher customWatcher = new();
    LogDetails? _selectedBreakpoint;
    LogDetails? selectedBreakpoint {
        get
        {
            return _selectedBreakpoint;
        }
        set
        {
            SubmitDisabled = value == null;
            _selectedBreakpoint = value;
        }
    }
    List<LogDetails>? breakpoints;
    Dictionary<string, TarkovMonitor.TaskStatus> TaskStatuses = new();
    bool SubmitDisabled { get; set; } = true;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        Task.Run(GetBreakPoints);

        Properties.Settings.Default.PropertyChanged += (object? sender, PropertyChangedEventArgs e) =>
        {
            if (e.PropertyName == "customLogsPath")
            {
                customWatcher.LogsPath = Properties.Settings.Default.customLogsPath;
                Task.Run(GetBreakPoints);
            }
        };
    }

    private void GetBreakPoints()
    {
        breakpoints = customWatcher.GetLogBreakpoints(GameWatcher.CurrentProfile.Id);
        InvokeAsync(() => StateHasChanged());
    }

    void Cancel() => MudDialog.Cancel();

    public async void Submit()
    {
        // Check if a path was selected, and if so, load the logs from that path
        if (selectedBreakpoint == null)
        {
            return;
        }
        if (!TarkovTracker.ValidToken)
        {
            messageLog.AddMessage("You must have a valid Tarkov Tracker API token to read past logs.", "exception");
        }
        SubmitDisabled = true;
        GameWatcher.ReadingPastLogs = true;
        TaskStatuses.Clear();
        Dictionary<string, TarkovMonitor.TaskStatus> updateTasks = new();
        try
        {
            //eft.ProcessLogs(selectedPath);
            customWatcher.TaskModified += UpdateTaskStatus;
            customWatcher.ProcessLogsFromBreakpoint(selectedBreakpoint);
            customWatcher.TaskModified -= UpdateTaskStatus;
            foreach (var kvp in TaskStatuses)
            {
                if (kvp.Value == TarkovMonitor.TaskStatus.Started)
                {
                    // don't update task status if started
                    continue;
                }
                var task = TarkovDev.Tasks.Find((t) => t.id == kvp.Key);
                if (task == null)
                {
                    // probably a daily
                    continue;
                }
                TarkovMonitor.TaskStatus savedTaskStatus = TarkovMonitor.TaskStatus.None;
                var taskProgress = TarkovTracker.Progress.data.tasksProgress.Find((prog) => prog.id == kvp.Key);
                if (taskProgress != null)
                {
                    if (taskProgress.failed)
                    {
                        savedTaskStatus = TarkovMonitor.TaskStatus.Failed;
                    }
                    if (taskProgress.complete)
                    {
                        savedTaskStatus = TarkovMonitor.TaskStatus.Finished;
                    }
                }
                if (kvp.Value == savedTaskStatus)
                {
                    // status matches, so don't update
                    continue;
                }
                updateTasks.Add(kvp.Key, kvp.Value);
                //System.Diagnostics.Debug.WriteLine($"Task {kvp.Key} should be {kvp.Value}");
                messageLog.AddMessage($"{kvp.Value} task {task.name}", "quest", $"https://tarkov.dev/task/{task.normalizedName}");
            }
        }
        catch (Exception ex)
        {
            messageLog.AddMessage($"Error compiling task updates: {ex.Message}", "exception");
            return;
        }
        finally
        {
            GameWatcher.ReadingPastLogs = false;
        }
        try
        {
            if (updateTasks.Count > 0)
            {
                await TarkovTracker.SetTaskStatuses(updateTasks);
                messageLog.AddMessage($"Updated status of {updateTasks.Count} tasks in Tarkov Tracker.", "info");
            }
            else
            {
                messageLog.AddMessage("No tasks found in past logs that require updating in Tarkov Tracker.", "info");
            }
            MudDialog.Close(DialogResult.Ok(true));
        }
        catch (Exception ex)
        {
            messageLog.AddMessage($"Error updating tasks: {ex.Message}", "exception");
        }
    }

    private void UpdateTaskStatus(object? sender, LogContentEventArgs<TaskStatusMessageLogContent> e)
    {
        TaskStatuses[e.LogContent.TaskId] = e.LogContent.Status;
    }
}